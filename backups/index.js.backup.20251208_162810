import express from 'express'
import cors from 'cors'
import path from 'path'
import { fileURLToPath } from 'url';
import mongoose from 'mongoose'
import router from './router/index.js';
import { createServer } from 'http';
import { initializeSocketIO } from './services/socket.service.js';

// ðŸ›¡ï¸ SECURITY DEPENDENCIES
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import slowDown from 'express-slow-down';
import mongoSanitize from 'express-mongo-sanitize';
import hpp from 'hpp';

// CONEXION A LA BASE DE DATOS
mongoose.Promise = global.Promise
const dbUrl = process.env.MONGO_URI;
mongoose.connect(
    dbUrl, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
}
).then(async mongoose => {
    console.log("Conectado a la base de datos MongoDB.");

    // Intentar inicializar CRON jobs (solo si node-cron estÃ¡ instalado)
    try {
        const { initializeCronJobs } = await import('./cron/index.js');
        initializeCronJobs();
    } catch (error) {
        console.log('\nâš ï¸  CRON jobs no inicializados (instala node-cron con: npm install node-cron)');
        console.log('   El sistema funcionarÃ¡ normalmente sin CRON jobs automÃ¡ticos.\n');
    }
})
    .catch(err => console.log(err));

const app = express();

// ðŸ›¡ï¸ SECURITY MIDDLEWARE CONFIGURATION

// 1. Helmet: Set security headers
app.use(helmet({
    crossOriginResourcePolicy: false, // Allow loading resources from different origins (needed for images)
    contentSecurityPolicy: false // Disable CSP for now to avoid breaking existing scripts/styles (enable later if needed)
}));

// 2. Rate Limiting: Limit repeated requests to public APIs
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 300, // Limit each IP to 300 requests per windowMs
    standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
    legacyHeaders: false, // Disable the `X-RateLimit-*` headers
    message: 'Too many requests from this IP, please try again after 15 minutes',
    skip: (req) => {
        // Skip rate limiting for trusted IPs or specific routes if needed
        // e.g., if (req.ip === '127.0.0.1') return true;
        return false;
    }
});
app.use('/api/', limiter); // Apply to all API routes

// 3. Speed Limiter: Slow down responses after a certain number of requests
const speedLimiter = slowDown({
    windowMs: 15 * 60 * 1000, // 15 minutes
    delayAfter: 100, // allow 100 requests per 15 minutes, then...
    delayMs: (hits) => hits * 100 // begin adding 100ms of delay per request above 100
});
app.use('/api/', speedLimiter);

// 4. Mongo Sanitize: Prevent NoSQL injection
app.use(mongoSanitize());

// 5. HPP: Prevent HTTP Parameter Pollution
app.use(hpp());

app.use(cors());

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

app.use(express.json({ limit: '50mb' })); // Increased limit for file uploads if needed
app.use(express.urlencoded({ extended: true, limit: '50mb' }))
app.use(express.static(path.join(__dirname, 'public')))

// ðŸ†• Ruta de redireccionamiento de Short URLs (debe ir ANTES de /api/)
import ShortUrlController from './controllers/ShortUrlController.js';
app.get('/s/:shortCode', ShortUrlController.redirect);

app.use('/api/', router)

// Custom error handler
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send({ message: 'An internal server error occurred.', error: err.message });
});

app.set('port', process.env.PUERTO || 3000);

// Crear servidor HTTP
const httpServer = createServer(app);

// Inicializar Socket.IO
initializeSocketIO(httpServer);

// Iniciar servidor
const server = httpServer.listen(app.get('port'), () => {
    console.log(`ðŸš€ Servidor ejecutÃ¡ndose en puerto ${app.get('port')}`);
    console.log(`ðŸ”Œ WebSocket disponible en ws://localhost:${app.get('port')}`);
});

// Manejo de cierre graceful del servidor
process.on('SIGTERM', async () => {
    console.log('\nâš ï¸  SIGTERM recibido. Cerrando servidor...');
    try {
        const { stopAllCronJobs } = await import('./cron/index.js');
        stopAllCronJobs();
    } catch (error) {
        // CRON jobs no estÃ¡n disponibles
    }
    server.close(() => {
        console.log('âœ… Servidor cerrado correctamente.');
        process.exit(0);
    });
});

process.on('SIGINT', async () => {
    console.log('\nâš ï¸  SIGINT recibido (Ctrl+C). Cerrando servidor...');
    try {
        const { stopAllCronJobs } = await import('./cron/index.js');
        stopAllCronJobs();
    } catch (error) {
        // CRON jobs no estÃ¡n disponibles
    }
    server.close(() => {
        console.log('âœ… Servidor cerrado correctamente.');
        process.exit(0);
    });
});
